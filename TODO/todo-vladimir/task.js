var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TaskList_tasks, _Title_text, _Task_id, _Task_title, _Task_state, _TaskInput_textInput, _TaskInput_checkBox, _TaskInput_container, _TaskInput_task, _TaskListComponent_tasks, _TaskListComponent_list, _TasksComponent_instances, _TasksComponent_tasks, _TasksComponent_wrapper, _TasksComponent_states, _TasksComponent_listing, _TasksComponent_listingWrapper, _TasksComponent_addTask, _TasksComponent_saveState, _TasksComponent_drawStates;
class ListSnapshot {
    constructor(name, tasks = []) {
        this.name = name;
        this.timestamp = new Date();
        this.tasks = tasks;
    }
}
class TaskList {
    constructor(tasks = []) {
        _TaskList_tasks.set(this, []);
        __classPrivateFieldSet(this, _TaskList_tasks, tasks, "f");
    }
    add(...tasks) {
        __classPrivateFieldGet(this, _TaskList_tasks, "f").push(...tasks);
    }
    remove(task) {
        __classPrivateFieldSet(this, _TaskList_tasks, __classPrivateFieldGet(this, _TaskList_tasks, "f").filter((t) => t !== task), "f");
    }
    toggle() {
        __classPrivateFieldGet(this, _TaskList_tasks, "f").forEach((task) => task.toggleState());
    }
    each(fn) {
        __classPrivateFieldGet(this, _TaskList_tasks, "f").forEach(fn);
    }
    reduce(fn, init) {
        return __classPrivateFieldGet(this, _TaskList_tasks, "f").reduce(fn, init);
    }
    makeSnapshot(name) {
        return new ListSnapshot(name, __classPrivateFieldGet(this, _TaskList_tasks, "f").map((t) => t.memento()));
    }
    restoreFrom(snapshot) {
        if (!(snapshot instanceof ListSnapshot))
            throw new Error('Snapshot is not of type ListSnapshot');
        __classPrivateFieldSet(this, _TaskList_tasks, snapshot.tasks.map((t) => new TmpTask().restoreFrom(t)), "f");
    }
}
_TaskList_tasks = new WeakMap();
class Title {
    constructor(text) {
        _Title_text.set(this, void 0);
        __classPrivateFieldSet(this, _Title_text, text, "f");
    }
    toString() {
        return __classPrivateFieldGet(this, _Title_text, "f");
    }
}
_Title_text = new WeakMap();
class Task {
    constructor(id, text) {
        _Task_id.set(this, void 0);
        _Task_title.set(this, new Title(''));
        _Task_state.set(this, 'todo');
        // should the ID actually be generated by the system?
        __classPrivateFieldSet(this, _Task_id, id, "f");
        __classPrivateFieldSet(this, _Task_title, new Title(text), "f");
    }
    getTitle() {
        return __classPrivateFieldGet(this, _Task_title, "f");
    }
    getState() {
        return __classPrivateFieldGet(this, _Task_state, "f");
    }
    updateTitle(text) {
        if (!text)
            throw new Error('Title cannot be empty');
        __classPrivateFieldSet(this, _Task_title, new Title(text), "f");
    }
    toggleState() {
        __classPrivateFieldSet(this, _Task_state, __classPrivateFieldGet(this, _Task_state, "f") === 'todo' ? 'done' : 'todo', "f");
    }
    toString() {
        return `${__classPrivateFieldGet(this, _Task_title, "f").toString()} - ${__classPrivateFieldGet(this, _Task_state, "f")}`;
    }
    memento() {
        return new Task(__classPrivateFieldGet(this, _Task_id, "f"), __classPrivateFieldGet(this, _Task_title, "f").toString());
    }
    restoreFrom(memento) {
        __classPrivateFieldSet(this, _Task_id, __classPrivateFieldGet(memento, _Task_id, "f"), "f");
        __classPrivateFieldSet(this, _Task_title, new Title(__classPrivateFieldGet(memento, _Task_title, "f").toString()), "f");
        __classPrivateFieldSet(this, _Task_state, __classPrivateFieldGet(memento, _Task_state, "f"), "f");
        return this;
    }
}
_Task_id = new WeakMap(), _Task_title = new WeakMap(), _Task_state = new WeakMap();
class TmpTask extends Task {
    constructor() {
        super(111, '');
    }
}
/**
  * TaskInput - will display a checkbox and a text input
  *   every time the input is updated the corresponding task will be updated as well
  */
class TaskInput {
    constructor(task) {
        _TaskInput_textInput.set(this, void 0);
        _TaskInput_checkBox.set(this, void 0);
        _TaskInput_container.set(this, void 0);
        _TaskInput_task.set(this, void 0);
        __classPrivateFieldSet(this, _TaskInput_task, task, "f");
        __classPrivateFieldSet(this, _TaskInput_container, document.createElement('div'), "f");
        __classPrivateFieldSet(this, _TaskInput_textInput, document.createElement('input'), "f");
        __classPrivateFieldGet(this, _TaskInput_textInput, "f").setAttribute('type', 'text');
        __classPrivateFieldGet(this, _TaskInput_textInput, "f").value = task.getTitle().toString();
        __classPrivateFieldSet(this, _TaskInput_checkBox, document.createElement('input'), "f");
        __classPrivateFieldGet(this, _TaskInput_checkBox, "f").setAttribute('type', 'checkbox');
        __classPrivateFieldGet(this, _TaskInput_container, "f").append(__classPrivateFieldGet(this, _TaskInput_textInput, "f"));
        __classPrivateFieldGet(this, _TaskInput_container, "f").append(__classPrivateFieldGet(this, _TaskInput_checkBox, "f"));
        __classPrivateFieldGet(this, _TaskInput_textInput, "f").addEventListener('change', () => {
            __classPrivateFieldGet(this, _TaskInput_task, "f").updateTitle(__classPrivateFieldGet(this, _TaskInput_textInput, "f").value);
        });
        __classPrivateFieldGet(this, _TaskInput_checkBox, "f").addEventListener('change', () => {
            __classPrivateFieldGet(this, _TaskInput_task, "f").toggleState();
        });
    }
    drawOn(parent) {
        parent.append(__classPrivateFieldGet(this, _TaskInput_container, "f"));
    }
}
_TaskInput_textInput = new WeakMap(), _TaskInput_checkBox = new WeakMap(), _TaskInput_container = new WeakMap(), _TaskInput_task = new WeakMap();
// maybe this is more of a layout strategy?
class KanbanComponent {
    constructor(tasks) { }
    drawOn(container) {
        container.innerText = 'Kanban';
    }
    add(...tasks) { }
}
class TaskListComponent {
    constructor(tasks) {
        _TaskListComponent_tasks.set(this, void 0);
        _TaskListComponent_list.set(this, void 0);
        __classPrivateFieldSet(this, _TaskListComponent_tasks, tasks, "f");
        __classPrivateFieldSet(this, _TaskListComponent_list, document.createElement("UL"), "f");
    }
    drawOn(container) {
        __classPrivateFieldGet(this, _TaskListComponent_tasks, "f").each((task) => {
            const li = document.createElement("LI");
            __classPrivateFieldGet(this, _TaskListComponent_list, "f").append(li);
            new TaskInput(task).drawOn(li);
        });
        container.append(__classPrivateFieldGet(this, _TaskListComponent_list, "f"));
    }
    add(...tasks) {
        for (const task of tasks) {
            const li = document.createElement("LI");
            __classPrivateFieldGet(this, _TaskListComponent_list, "f").append(li);
            new TaskInput(task).drawOn(li);
        }
    }
}
_TaskListComponent_tasks = new WeakMap(), _TaskListComponent_list = new WeakMap();
class TasksComponent {
    constructor(tasks, listing) {
        _TasksComponent_instances.add(this);
        _TasksComponent_tasks.set(this, void 0);
        _TasksComponent_wrapper.set(this, void 0);
        this.states = [];
        _TasksComponent_states.set(this, void 0);
        _TasksComponent_listing.set(this, undefined);
        _TasksComponent_listingWrapper.set(this, void 0);
        __classPrivateFieldSet(this, _TasksComponent_listing, listing, "f");
        __classPrivateFieldSet(this, _TasksComponent_tasks, tasks, "f");
        __classPrivateFieldSet(this, _TasksComponent_wrapper, document.createElement('div'), "f");
        __classPrivateFieldSet(this, _TasksComponent_listingWrapper, document.createElement('div'), "f");
        const addBtn = document.createElement("BUTTON");
        addBtn.innerText = "Add";
        addBtn.onclick = __classPrivateFieldGet(this, _TasksComponent_instances, "m", _TasksComponent_addTask).bind(this);
        const saveBtn = document.createElement("BUTTON");
        saveBtn.innerText = "Save State";
        saveBtn.onclick = __classPrivateFieldGet(this, _TasksComponent_instances, "m", _TasksComponent_saveState).bind(this);
        __classPrivateFieldSet(this, _TasksComponent_states, document.createElement("div"), "f");
        __classPrivateFieldGet(this, _TasksComponent_wrapper, "f").append(addBtn);
        __classPrivateFieldGet(this, _TasksComponent_wrapper, "f").append(saveBtn);
        __classPrivateFieldGet(this, _TasksComponent_wrapper, "f").append(__classPrivateFieldGet(this, _TasksComponent_listingWrapper, "f"));
        __classPrivateFieldGet(this, _TasksComponent_wrapper, "f").append(__classPrivateFieldGet(this, _TasksComponent_states, "f"));
    }
    /**
    * The listing should also be set in the constructor, but this way we get to use optional chaining
    * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining
    */
    setListing(listing) {
        __classPrivateFieldSet(this, _TasksComponent_listing, listing, "f");
    }
    drawOn(container) {
        var _a;
        container.append(__classPrivateFieldGet(this, _TasksComponent_wrapper, "f"));
        (_a = __classPrivateFieldGet(this, _TasksComponent_listing, "f")) === null || _a === void 0 ? void 0 : _a.drawOn(__classPrivateFieldGet(this, _TasksComponent_listingWrapper, "f"));
    }
    destroy() {
        __classPrivateFieldGet(this, _TasksComponent_wrapper, "f").remove();
    }
}
_TasksComponent_tasks = new WeakMap(), _TasksComponent_wrapper = new WeakMap(), _TasksComponent_states = new WeakMap(), _TasksComponent_listing = new WeakMap(), _TasksComponent_listingWrapper = new WeakMap(), _TasksComponent_instances = new WeakSet(), _TasksComponent_addTask = function _TasksComponent_addTask() {
    const task = new Task(1, '...');
}, _TasksComponent_saveState = function _TasksComponent_saveState() {
    this.states.push(__classPrivateFieldGet(this, _TasksComponent_tasks, "f").makeSnapshot('initial'));
    __classPrivateFieldGet(this, _TasksComponent_instances, "m", _TasksComponent_drawStates).call(this);
}, _TasksComponent_drawStates = function _TasksComponent_drawStates() {
    __classPrivateFieldGet(this, _TasksComponent_states, "f").innerHTML = '';
    this.states.forEach((state) => {
        const li = document.createElement('li');
        li.innerText = `${state.name}`;
        __classPrivateFieldGet(this, _TasksComponent_states, "f").append(li);
    });
};
export { TaskList, Task, TaskInput, TasksComponent, TaskListComponent, KanbanComponent };

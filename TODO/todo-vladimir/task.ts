
interface Snapshot {
  name: string
  readonly timestamp: Date
}

interface Snappable {
  makeSnapshot(name: string): Snapshot
  restoreFrom(snapshot: Snapshot): void
}

class ListSnapshot implements Snapshot {
  name: string
  readonly timestamp: Date
  tasks: Task[]

  constructor(name: string, tasks: Task[] = []) {
    this.name = name
    this.timestamp = new Date()
    this.tasks = tasks
  }
}

class TaskList implements Snappable {
  #tasks: Task[] = []

  constructor(tasks: Task[] = []) {
    this.#tasks = tasks
  }

  add(...tasks: Task[]) {
    this.#tasks.push(...tasks)
  }

  remove(task: Task) {
    this.#tasks = this.#tasks.filter((t) => t !== task)
  }

  toggle() {
    this.#tasks.forEach((task) => task.toggleState())
  }

  each(fn: (task: Task) => void) {
    this.#tasks.forEach(fn)
  }

  reduce(fn: (acc: any, task: Task) => any, init: any) {
    return this.#tasks.reduce(fn, init)
  }

  makeSnapshot(name: string): Snapshot {
    return new ListSnapshot(name, this.#tasks.map((t) => t.memento()))
  }

  restoreFrom(snapshot: Snapshot) {
    if (!(snapshot instanceof ListSnapshot)) throw new Error('Snapshot is not of type ListSnapshot')

    this.#tasks = snapshot.tasks.map((t) => new TmpTask().restoreFrom(t))
  }
}

class Title {
  #text: string
  constructor(text: string) {
    this.#text = text
  }

  toString() {
    return this.#text
  }
}

type TaskState = 'todo' | 'done'
class Task {
  #id: number
  #title: Title = new Title('')
  #state: TaskState = 'todo'

  constructor(id: number, text: string) {
    // should the ID actually be generated by the system?
    this.#id = id
    this.#title = new Title(text)
  }

  getTitle() {
    return this.#title
  }

  getState(): string {
    return this.#state
  }

  updateTitle(text: string) {
    if (!text) throw new Error('Title cannot be empty')
    this.#title = new Title(text)
  }

  toggleState() {
    this.#state = this.#state === 'todo' ? 'done' : 'todo'
  }

  toString() {
    return `${this.#title.toString()} - ${this.#state}`
  }

  memento() {
    return new Task(this.#id, this.#title.toString())
  }

  restoreFrom(memento: Task): this {
    this.#id = memento.#id
    this.#title = new Title(memento.#title.toString())
    this.#state = memento.#state
    return this
  }
}

class TmpTask extends Task {
  constructor() {
    super(111, '')
  }
}

/**
  * TaskInput - will display a checkbox and a text input
  *   every time the input is updated the corresponding task will be updated as well
  */
class TaskInput {
  #textInput: HTMLInputElement
  #checkBox: HTMLInputElement
  #container: HTMLDivElement
  #task: Task

  constructor(task: Task) {
    this.#task = task

    this.#container = document.createElement('div')

    this.#textInput = document.createElement('input')
    this.#textInput.setAttribute('type', 'text')
    this.#textInput.value = task.getTitle().toString()

    this.#checkBox = document.createElement('input')
    this.#checkBox.setAttribute('type', 'checkbox')

    this.#container.append(this.#textInput)
    this.#container.append(this.#checkBox)

    this.#textInput.addEventListener('change', () => {
      this.#task.updateTitle(this.#textInput.value)
    })

    this.#checkBox.addEventListener('change', () => {
      this.#task.toggleState()
    })
  }

  drawOn(parent: HTMLElement): void {
    parent.append(this.#container)
  }
}

// Each TaskListinging would then draw its own types of inputs
interface TaskListing {
  drawOn(container: HTMLElement): void

  add(...tasks: Task[]): void
}

// maybe this is more of a layout strategy?
class KanbanComponent implements TaskListing {
  constructor(tasks: TaskList) { }

  drawOn(container: HTMLElement) {
    container.innerText = 'Kanban'
  }

  add(...tasks: Task[]): void { }
}

class TaskListComponent implements TaskListing {
  #tasks: TaskList
  #list: HTMLElement

  constructor(tasks: TaskList) {
    this.#tasks = tasks
    this.#list = document.createElement("UL")
  }

  drawOn(container: HTMLElement) {
    this.#tasks.each((task) => {
      const li = document.createElement("LI")
      this.#list.append(li)
      new TaskInput(task).drawOn(li)
    })
    container.append(this.#list)
  }

  add(...tasks: Task[]): void {
    for (const task of tasks) {
      const li = document.createElement("LI")
      this.#list.append(li)
      new TaskInput(task).drawOn(li)
    }
  }
}

class TasksComponent {
  #tasks: TaskList

  #wrapper: HTMLDivElement
  states: Snapshot[] = []
  #states: HTMLElement
  #listing: TaskListing | undefined = undefined
  #listingWrapper: HTMLDivElement

  constructor(tasks: TaskList, listing: TaskListing) {
    this.#listing = listing
    this.#tasks = tasks

    this.#wrapper = document.createElement('div')
    this.#listingWrapper = document.createElement('div')

    const addBtn = document.createElement("BUTTON")
    addBtn.innerText = "Add"
    addBtn.onclick = this.#addTask.bind(this)

    const saveBtn = document.createElement("BUTTON")
    saveBtn.innerText = "Save State"
    saveBtn.onclick = this.#saveState.bind(this)

    this.#states = document.createElement("div")

    this.#wrapper.append(addBtn)
    this.#wrapper.append(saveBtn)
    this.#wrapper.append(this.#listingWrapper)
    this.#wrapper.append(this.#states)
  }

  /**
  * The listing should also be set in the constructor, but this way we get to use optional chaining
  * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining
  */
  setListing(listing: TaskListing) {
    this.#listing = listing
  }

  drawOn(container: HTMLElement) {
    container.append(this.#wrapper)
    this.#listing?.drawOn(this.#listingWrapper)
  }

  #addTask() {
    const task = new Task(1, '...')
  }

  #saveState() {
    this.states.push(this.#tasks.makeSnapshot('initial'))
    this.#drawStates()
  }

  #drawStates() {
    this.#states.innerHTML = ''
    this.states.forEach((state) => {
      const li = document.createElement('li')
      li.innerText = `${state.name}`
      this.#states.append(li)
    })
  }

  destroy() {
    this.#wrapper.remove()
  }
}

export { TaskList, Task, TaskInput, TasksComponent, TaskListComponent, KanbanComponent, Snapshot }

